include:
  - local: "commons/kubetools/.gitlab-ci.yml"
  - local: "commons/sonarqube/.gitlab-ci.yml"

validate_env:
  stage: .pre
  image: ubuntu:20.04
  script:
    - |
      if [ -z ${BASE_DOMAIN} ]; then echo "BASE_DOMAIN must be set"; exit 1; fi

.cd-to-module: &cd-to-module |
  export MODULE_PATH=${MODULE_PATH:-${MODULE_NAME}}
  [ "${GIT_STRATEGY}" != "none" ] && [ "${MODULE_PATH}" != "" ] && cd ${MODULE_PATH}

.commons:
  variables:
    GIT_STRATEGY: clone
    MODULE_NAME: ""
    MODULE_PATH: ""
    COMMON_NAME: common
    SAST_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/sast-audit:1.0
    #DOCKER_TLS_CERTDIR: ""
    #DOCKER_DRIVER: overlay2
    KUBETOOLS_IMAGE_TAGNAME: ${CI_REGISTRY}/${CI_PROJECT_PATH}/kubetools:${CI_COMMIT_REF_SLUG}-${CI_PIPELINE_ID}
    DUMP_IMAGE_NAME: ${CI_REGISTRY}/${CI_PROJECT_PATH}/dump:${CI_COMMIT_REF_SLUG}-${CI_PIPELINE_ID}
    IMAGE_PULL_SECRET_PREFIX: gitlab-registry
    PROXY_IMAGE_PULL_SECRET_PREFIX: nexus-registry
    GITLAB_PROJECT_PATH: ${CI_PROJECT_PATH}
    GITLAB_BRANCH: ${CI_COMMIT_REF_NAME}
    GITLAB_URL: ${CI_SERVER_URL}
    BRANCH_NAME: ${CI_COMMIT_REF_SLUG}
    IMAGE_TAG_NAME: ${CI_COMMIT_REF_SLUG}-${CI_PIPELINE_ID}
    REGISTRY_USER: ${CI_REGISTRY_USER}
    REGISTRY_PASSWORD: ${CI_REGISTRY_PASSWORD}
    REGISTRY_BASE_NAME: ${CI_REGISTRY_IMAGE}
    REGISTRY_URL: ${CI_REGISTRY}
    NEXUS_DOCKER_REGISTRY_URL: ${NEXUS_DOCKER_REGISTRY}
    NEXUS_USER_NAME: ${NEXUS_USER_NAME}
    NEXUS_USER_PWD: ${NEXUS_USER_PWD}
    BUILD_IMAGE_NAME: ${NEXUS_DOCKER_REGISTRY}/node:12.13.0-alpine
    VERIFY_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/mcm-verify:${CI_COMMIT_REF_SLUG}-${CI_PIPELINE_ID}
    TEST_IMAGE_NAME: ${NEXUS_DOCKER_REGISTRY}/node:12.13.0-alpine
  before_script:
    - *cd-to-module

.no-git-clone:
  variables:
    GIT_STRATEGY: none

.no-dependencies:
  dependencies: []

.no-needs:
  needs: []

.manual:
  when: manual

.only-master:
  only:
    refs:
      - master

# Testing suppose to be ref on master and created by tag
.only-testing:
  only:
    refs:
      - tags

.predicate-skip-tests-verify-yes: &predicate-skip-tests-verify-yes $SKIP_TEST == "yes"

.except-skip-tests:
  except:
    variables:
      - *predicate-skip-tests-verify-yes

.predicate-sast-yes: &predicate-sast-yes $DO_SAST == "yes"

.only-sast:
  only:
    variables:
      - *predicate-sast-yes

.except-sast:
  except:
    variables:
      - *predicate-sast-yes

.predicate-clean-yes: &predicate-clean-yes $CLEAN_DATA == "yes"

.only-clean:
  only:
    variables:
      - *predicate-clean-yes

.except-clean:
  except:
    variables:
      - *predicate-clean-yes

.except-clean-or-skip:
  except:
    variables:
      - *predicate-clean-yes
      - *predicate-skip-tests-verify-yes

# Helper templates to specify intents of jobs, and select appropriate runners

.build-job-tags:
  tags:
    - os:linux
    - task:build

.build-n-sast-job-tags:
  tags:
    - os:linux
    - task:build-n-sast

.image-job-tags:
  tags:
    - os:linux
    - task:image

.test-job-tags:
  tags:
    - os:linux
    - task:test

.preview-deploy-tags:
  tags:
    - os:linux
    - platform:dev
    - task:deploy

.testing-deploy-tags:
  tags:
    - os:linux
    - platform:testing
    - task:deploy

.preprod-deploy-tags:
  tags:
    - os:linux
    - platform:preprod
    - task:deploy

.build-job:
  extends:
    - .commons
    - .build-job-tags
    - .except-clean
  stage: build
  image: ${BUILD_IMAGE_NAME}

.website-content-job:
  extends:
    - .commons
    - .build-job-tags
    - .except-clean
  stage: website-content
  image: ${BUILD_IMAGE_NAME}

.declare-image-functions: &declare-image-functions |
  function image {
      docker login -u ${REGISTRY_USER} -p ${REGISTRY_PASSWORD} ${REGISTRY_URL}
      docker login -u ${NEXUS_USER_NAME} -p ${NEXUS_USER_PWD} ${NEXUS_DOCKER_REGISTRY_URL}
      docker-compose --file ${COMPOSE_FILENAME} build
      docker-compose --file ${COMPOSE_FILENAME} push
  }

.pre-image-job:
  extends:
    - .commons
    - .image-job-tags
    - .except-clean
  stage: pre-image
  variables:
    COMPOSE_FILENAME: kompose.yml
  image: ${NEXUS_DOCKER_REGISTRY_URL}/tiangolo/docker-with-compose:2021-09-18
  before_script:
    - *cd-to-module
    - *declare-image-functions
  script:
    - |
      image

.image-job:
  extends:
    - .commons
    - .image-job-tags
  stage: image
  variables:
    COMPOSE_FILENAME: kompose.yml
  image: ${NEXUS_DOCKER_REGISTRY_URL}/tiangolo/docker-with-compose:2021-09-18
  before_script:
    - *cd-to-module
    - *declare-image-functions
  script:
    - |
      image

.test-job:
  stage: test
  extends:
    - .commons
    - .test-job-tags
    - .except-clean-or-skip
  artifacts:
    paths:
      - ${MODULE_PATH:-${MODULE_NAME}}/junit.xml
      - ${MODULE_PATH:-${MODULE_NAME}}/coverage
    when: always
    reports:
      junit:
        - ${MODULE_PATH:-${MODULE_NAME}}/junit.xml

.sast_init_vars: &sast_init_vars |
  export SAST_LOG_FILE=sast_data_${RELEASE_NAME}.log

.archive_sast_script: &archive_sast_script |
  # Check if node_modules exists
  if [ ! -d node_modules ]; then
      echo "node_modules is not there, SAST analysis can not be performed" && exit 1
  fi
  # Create an archive with data to scan
  echo "Create archive "${RELEASE_NAME}.zip" with data to scan..."
  zip -u -qq -r ${RELEASE_NAME}.zip .
  echo "...archive created"

.run_sast_script: &run_sast_script |
  # Create a new FoD release if it not exists
  [ -z '${SDLC_STATUS}' ] && export SDLC_STATUS=3

  touch ${SAST_LOG_FILE}
  touch ${SAST_RESULT_FILE}
  ls -altr .
  createCommandExit=""
  runCommandExit=""

  if [ "$COPY_FROM_RELEASE" = "" ]
  then
      createCommandExit=`java -jar /usr/lib/FodAPIClient.jar ${FOD_AUTHENTICATION_ARGS} create-release -an ${FOD_APPLICATION_NAME} -rn ${RELEASE_NAME} -sdlc ${SDLC_STATUS} -rd '${RELEASE_DESCRIPTION}' | awk -F ',' '{print($2)}'`
  else
      createCommandExit=`java -jar /usr/lib/FodAPIClient.jar ${FOD_AUTHENTICATION_ARGS} create-release -an ${FOD_APPLICATION_NAME} -rn ${RELEASE_NAME} -sdlc ${SDLC_STATUS} -rd '${RELEASE_DESCRIPTION}' -copy -copyRelease ${COPY_FROM_RELEASE} | awk -F ',' '{print($2)}'`
  fi

  echo $createCommandExit >> ${SAST_LOG_FILE}
  releaseId=`echo $createCommandExit | awk -F '=' '{print($2)}'`

  optionArgs=""

  [ ${ALLOW_POLICY_FAIL} = 'false' ] && optionArgs="${optionArgs} -policy"
  [ ${INCLUDE_THIRD_PARTY_LIBS} = 'true' ] && optionArgs="${optionArgs} -itp"
  [ ${RUN_SONATYPE_SCAN} = 'true' ] && optionArgs="${optionArgs} -oss"

  # Run the scan
  runCommandExit=`java -jar /usr/lib/FodAPIClient.jar ${FOD_AUTHENTICATION_ARGS} static-scan -z ${RELEASE_NAME}.zip -tid ${FOD_TENANT_ID} -rid $releaseId -I ${POLLING_INTERVAL} ${optionArgs} -pp ${IN_PROGRESS_SCAN_ACTION_TYPE} -rp ${REMEDIATION_SCAN_PREFERENCE_TYPE} -tech ${TECHNOLOGY_TYPE} -o ${SAST_RESULT_FILE}`
  scanId=`echo $runCommandExit | grep -o -P "Scan.?[0-9]*" | awk -F 'Scan ' '{print($2)}'`
  echo "scanId=$scanId" >> ${SAST_LOG_FILE}
  echo "Download FPR at ${FOD_PORTAL_URL}/Releases/$releaseId/Scans" >> ${SAST_LOG_FILE}

.sast-job:
  stage: static-assessment
  extends:
    - .commons
    - .build-n-sast-job-tags
    - .except-clean-or-skip
  image: ${SAST_IMAGE_NAME}
  variables:
    FOD_AUTHENTICATION_ARGS: -ac ${FOD_API_KEY} ${FOD_API_ACCESS_KEY} -tc ${FOD_TENANT_CODE} -aurl ${FOD_API_URL} -purl ${FOD_PORTAL_URL}
    # Should be the name of an existing release. Keep empty to create a proper new version
    COPY_FROM_RELEASE: ""
    RELEASE_DESCRIPTION: Scan for ${MODULE_NAME} from ${CI_COMMIT_REF_SLUG}
    RELEASE_NAME: ${MODULE_NAME}-${CI_COMMIT_REF_SLUG}-MR
    # [1:Production, 2:QA, 3:Development, 4:Retired]
    SDLC_STATUS: 3
    SAST_RESULT_FILE: result_summary.json
    # Polling interval for retrieving results. If 0, the scan will be performed asynchronously. Value in minutes
    POLLING_INTERVAL: 5
    ALLOW_POLICY_FAIL: "true"
    # [0:DoNotStartScan, 1:CancelInProgressScan, 2:Queue]
    IN_PROGRESS_SCAN_ACTION_TYPE: 2
    INCLUDE_THIRD_PARTY_LIBS: "false"
    RUN_SONATYPE_SCAN: "true"
    # [0:RemediationScanIfAvailable, 1:RemediationScanOnly, 2:NonRemediationScanOnly]
    REMEDIATION_SCAN_PREFERENCE_TYPE: 2
    TECHNOLOGY_TYPE: JS/TS/HTML
  script:
    - *sast_init_vars
    - *archive_sast_script
    - *run_sast_script
  artifacts:
    paths:
      # The result file may be empty regarding to the value passed to POLLING_INTERVAL
      # whereas the log file will contain the release ID and the scan ID
      - ${MODULE_PATH:-${MODULE_NAME}}/${SAST_LOG_FILE}
      - ${MODULE_PATH:-${MODULE_NAME}}/${SAST_RESULT_FILE}

.verify-job:
  extends:
    - .commons
    - .test-job-tags
    - .except-clean-or-skip
  image: ${VERIFY_IMAGE_NAME}
  stage: verify
  variables:
    SONAR_SOURCES: .
    SONAR_EXCLUSIONS: "sonar.exclusions=**/node_modules/**,dist/**,databaseConfig/**,public/**,coverage/**,**/__tests__/**,**.yml,**.json,**.md,eslintrc.js"
    SONAR_CPD_EXCLUSIONS: "**/__tests__/**,src/datasources/**,src/models/**,src/repositories/**"
  needs: ["sonarqube-verify-image-build"]
  script:
    - |
      cd /opt/mcm-verify/
      ./verify.sh
  artifacts:
    paths:
      - ${MODULE_PATH:-${MODULE_NAME}}/sonarqube_quality_gate_report
      - ${MODULE_PATH:-${MODULE_NAME}}/sonarqube_issues

.verify-all-script: &verify-all-script /opt/mcm-verify/convert_sonarqube_issues.sh

verify_all:
  extends:
    - .commons
    - .test-job-tags
    - .except-clean-or-skip
  stage: verify_all
  image: ${VERIFY_IMAGE_NAME}
  script:
    - *verify-all-script
  artifacts:
    paths:
      - gl-code-quality-report.json
    reports:
      codequality: gl-code-quality-report.json

.cleanup_mongo: &cleanup_mongo |
  echo "MONGO CLEANING START"
  echo ${BRANCH_NAME}
  echo $(kubectl get pods -o wide -A)
  MONGO_POD_NAME=$(kubectl get pods -o wide -A | grep ${BRANCH_NAME} | grep mongo | awk '{ print $2 }')
  MONGO_NAMESPACE=$(kubectl get pods -o wide -A | grep ${BRANCH_NAME} | grep mongo | awk '{ print $1 }')
  kubectl exec $MONGO_POD_NAME -n $MONGO_NAMESPACE -- sh -c \
    "mongosh --username ${MONGO_SERVICE_USER} --password ${MONGO_SERVICE_PASSWORD} --authenticationDatabase ${MONGO_DB_NAME} --authenticationMechanism SCRAM-SHA-256 --eval \"db=db.getSiblingDB('${MONGO_DB_NAME}'); db.getCollectionNames().forEach(function(c) { if (c.indexOf('system.') == -1) db[c].deleteMany({}); }); quit(0);\"exit"
  echo "MONGO CLEANING STOP"

.cleanup_postgres-keycloak: &cleanup_postgres-keycloak |
  echo "POSTGRES IDP CLEANING START"
  echo ${BRANCH_NAME}
  IDP_POD_NAME=$(kubectl get pods -o wide -A | grep ${BRANCH_NAME} | grep idp | awk '{ print $2 }')
  IDP_NAMESPACE=$(kubectl get pods -o wide -A | grep ${BRANCH_NAME} | grep idp | awk '{ print $1 }')
  echo "INIT CONNECTION"
  kubectl exec $IDP_POD_NAME -n $IDP_NAMESPACE -c idp -- sh -c \
  "/opt/jboss/keycloak/bin/kcadm.sh config credentials --server http://localhost:8080/auth --realm master --user ${KEYCLOAK_USER} --password ${KEYCLOAK_PASSWORD}"
  echo "---------"
  echo "GET USERS"
  USER_LIST_ID=$(kubectl exec $IDP_POD_NAME -n $IDP_NAMESPACE -c idp -- sh -c "/opt/jboss/keycloak/bin/kcadm.sh get users -r mcm --fields id" | jq -r '.[] | .id')
  echo $USER_LIST_ID
  if [ -z "$USER_LIST_ID" ]
  then
    echo "No user to delete"
  else
    echo "---------"
    echo "DELETE USERS"
    for i in $USER_LIST_ID
    do
      $(kubectl exec $IDP_POD_NAME -n $IDP_NAMESPACE -c idp -- sh -c "/opt/jboss/keycloak/bin/kcadm.sh delete users/$i -r mcm")
    done
  fi
  echo "---------"
  echo "GET GROUPS"
  GROUP_LIST_ID=$(kubectl exec $IDP_POD_NAME -n $IDP_NAMESPACE -c idp -- sh -c "/opt/jboss/keycloak/bin/kcadm.sh get groups -r mcm" | jq -r '.[] | select( .name == "entreprises" or .name == "collectivitÃ©s") | .subGroups | .[] | .id')
  echo $GROUP_LIST_ID
  if [ -z "$GROUP_LIST_ID" ]
  then
    echo "No group to delete"
  else
    echo "---------"
    echo "DELETE GROUPS"
    for i in $GROUP_LIST_ID
    do
      $(kubectl exec $IDP_POD_NAME -n $IDP_NAMESPACE -c idp -- sh -c "/opt/jboss/keycloak/bin/kcadm.sh delete groups/$i -r mcm")
    done
  fi
  echo "POSTGRES IDP CLEANING STOP"

.mongo-clean-data:
  stage: prime_preview
  extends:
    - .commons
    - .test-job-tags
  image: ${KUBETOOLS_IMAGE_TAGNAME}
  script:
    - *cleanup_mongo

.postgres-clean-data:
  stage: prime_preview
  extends:
    - .commons
    - .test-job-tags
  image: ${KUBETOOLS_IMAGE_TAGNAME}
  script:
    - *cleanup_postgres-keycloak

.preview-env-vars:
  variables:
    LANDSCAPE: "preview"
    landscape_subdomain: "preview.${BASE_DOMAIN}"
    SECRET_NAME: ${MODULE_NAME}-tls
    CLUSTER_ISSUER: clusterissuer-mcm-dev
    ADMIN_FQDN: admin-${CI_COMMIT_REF_SLUG}.preview.${BASE_DOMAIN}
    ANTIVIRUS_FQDN: antivirus.preview.${BASE_DOMAIN}
    API_FQDN: api-${CI_COMMIT_REF_SLUG}.preview.${BASE_DOMAIN}
    S3_FQDN: s3.preview.${BASE_DOMAIN}
    GK_FQDN: gk-${CI_COMMIT_REF_SLUG}.preview.${BASE_DOMAIN}
    IDP_FQDN: idp-${CI_COMMIT_REF_SLUG}.preview.${BASE_DOMAIN}
    MATOMO_FQDN: analytics-${CI_COMMIT_REF_SLUG}.preview.${BASE_DOMAIN}
    VAULT_FQDN: vault-${CI_COMMIT_REF_SLUG}.preview.${BASE_DOMAIN}
    WEBSITE_FQDN: website-${CI_COMMIT_REF_SLUG}.preview.${BASE_DOMAIN}
    SIMULATION_MAAS_FQDN: simulation-maas-${CI_COMMIT_REF_SLUG}.preview.${BASE_DOMAIN}
    MAILHOG_FQDN: mailhog-${CI_COMMIT_REF_SLUG}.preview.${BASE_DOMAIN}

.testing-env-vars:
  variables:
    LANDSCAPE: "testing"
    landscape_subdomain: "testing.${BASE_DOMAIN}"
    SECRET_NAME: ${MODULE_NAME}-tls
    CLUSTER_ISSUER: clusterissuer-mcm-dev
    ADMIN_FQDN: admin-${CI_COMMIT_REF_SLUG}.testing.${BASE_DOMAIN}
    ANTIVIRUS_FQDN: antivirus-${CI_COMMIT_REF_SLUG}.testing.${BASE_DOMAIN}
    API_FQDN: api-${CI_COMMIT_REF_SLUG}.testing.${BASE_DOMAIN}
    S3_FQDN: s3-${CI_COMMIT_REF_SLUG}.testing.${BASE_DOMAIN}
    GK_FQDN: gk-${CI_COMMIT_REF_SLUG}.testing.${BASE_DOMAIN}
    IDP_FQDN: idp-${CI_COMMIT_REF_SLUG}.testing.${BASE_DOMAIN}
    MATOMO_FQDN: analytics-${CI_COMMIT_REF_SLUG}.testing.${BASE_DOMAIN}
    VAULT_FQDN: vault-${CI_COMMIT_REF_SLUG}.testing.${BASE_DOMAIN}
    WEBSITE_FQDN: website-${CI_COMMIT_REF_SLUG}.testing.${BASE_DOMAIN}
    SIMULATION_MAAS_FQDN: simulation-maas-${CI_COMMIT_REF_SLUG}.testing.${BASE_DOMAIN}

#TODO switch to TAG VAR - digit
.preprod-env-vars:
  variables:
    LANDSCAPE: "preprod"
    landscape_subdomain: "preprod.${BASE_DOMAIN}"
    SECRET_NAME: ${MODULE_NAME}-tls
    CLUSTER_ISSUER: clusterissuer-mcm-preprod
    ADMIN_FQDN: admin-${URL_TAG}.preprod.${BASE_DOMAIN}
    ANTIVIRUS_FQDN: antivirus-${URL_TAG}.preprod.${BASE_DOMAIN}
    API_FQDN: api-${URL_TAG}.preprod.${BASE_DOMAIN}
    S3_FQDN: s3.preprod.${BASE_DOMAIN}
    GK_FQDN: gk-${URL_TAG}.preprod.${BASE_DOMAIN}
    IDP_FQDN: idp-${URL_TAG}.preprod.${BASE_DOMAIN}
    MATOMO_FQDN: analytics-${URL_TAG}.preprod.${BASE_DOMAIN}
    VAULT_FQDN: vault-${URL_TAG}.preprod.${BASE_DOMAIN}
    WEBSITE_FQDN: website-${URL_TAG}.preprod.${BASE_DOMAIN}
    SIMULATION_MAAS_FQDN: simulation-maas-${URL_TAG}.preprod.${BASE_DOMAIN}

.auto-stop-preview:
  environment:
    auto_stop_in: 3 days

.auto-stop-testing:
  environment:
    auto_stop_in: 1 week

.declare-deployment-functions: &declare-deployment-functions |
  function deploy {
    echo "deploying: ${MODULE_NAME} for ${CI_ENVIRONMENT_TIER}, subdomain ${LANDSCAPE}..."
    export GITLAB_IMAGE_PULL_SECRET_NAME=${IMAGE_PULL_SECRET_PREFIX}-${MODULE_NAME}
    export PROXY_IMAGE_PULL_SECRET_NAME=${PROXY_IMAGE_PULL_SECRET_PREFIX}-${MODULE_NAME}
    kubectl create secret docker-registry ${GITLAB_IMAGE_PULL_SECRET_NAME} --docker-server="$CI_REGISTRY" --docker-username="$CI_DEPLOY_USER" --docker-password="$CI_DEPLOY_PASSWORD" --docker-email="$GITLAB_USER_EMAIL" -o yaml --dry-run=client | kubectl apply -f -
    kubectl create secret docker-registry ${PROXY_IMAGE_PULL_SECRET_NAME} --docker-server="$NEXUS_DOCKER_REGISTRY_URL" --docker-username="$NEXUS_USER_NAME" --docker-password="$NEXUS_USER_PWD" --docker-email="$GITLAB_USER_EMAIL" -o yaml --dry-run=client | kubectl apply -f -
    chmod 777 /usr/local/bin/a
    chmod 777 /usr/local/bin/k
    mkdir -p ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE} && ENV_PATH=${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/params.env KOMPOSE_FILE=$1 k | tee ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/template.yml
    echo "Special condition for ${MODULE_NAME}"
    if [ ${MODULE_NAME} = "idp" ]
    then
      sed -i 's/"${/##/g' ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/template.yml
      sed -i 's/access.${/%%/g' ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/template.yml
      cat ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/template.yml | envsubst | tee ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/resources.yml
      sed -i 's/##/"${/g' ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/resources.yml
      sed -i 's/%%/access.${/g' ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/resources.yml
    else
      cat ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/template.yml | envsubst | tee ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/resources.yml
    fi
    cat ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/resources.yml | a
    cat ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/params.env | envsubst > ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/values.env
  }
  function undeploy {
    export GITLAB_IMAGE_PULL_SECRET_NAME=${IMAGE_PULL_SECRET_PREFIX}-${MODULE_NAME}
    export PROXY_IMAGE_PULL_SECRET_NAME=${PROXY_IMAGE_PULL_SECRET_PREFIX}-${MODULE_NAME}
    kubectl delete -f ${CI_PROJECT_DIR}/${MODULE_PATH}/k8s/${LANDSCAPE}/resources.yml
    kubectl delete secret ${GITLAB_IMAGE_PULL_SECRET_NAME}
    kubectl delete secret ${PROXY_IMAGE_PULL_SECRET_NAME}
  }
  function pod_namespace {
    kubectl get pods -o wide --all-namespaces | grep -- -${BRANCH_NAME}- | grep $1 | awk '{ print $1 }' | head -n 1
  }
  function config_volume {
    PV_CHECK=$(kubectl get pv -o wide --all-namespaces | grep ${BRANCH_NAME} | grep $1 | awk '{ print $1 }')
    if [ $PV_CHECK != "" ]
    then
        echo "### Patch the persistent volume to retain than delete for $1 ###"
        kubectl patch pv $PV_CHECK -p '{"spec":{"persistentVolumeReclaimPolicy":"Retain"}}'
    fi
  }
  function delete_volume {
    PV_TO_DELETE=$(kubectl get pv -o wide --all-namespaces | grep ${BRANCH_NAME} | grep $1 | awk '{ print $1 }')
    if [ $PV_TO_DELETE != "" ]
    then
        echo "### Patch the persistent volume to delete than retain for $1 ###"
        kubectl patch pv $PV_TO_DELETE -p '{"spec":{"persistentVolumeReclaimPolicy":"Delete"}}'
    fi
  }
  function wait_pod {
    while [[ $(pod_namespace $1) == "" ]]
    do
      echo "Wait $1 try"
      sleep 10
    done
  }

.deploy-job:
  extends:
    - .commons
    - .except-clean
    - .no-dependencies
  image: ${KUBETOOLS_IMAGE_TAGNAME}
  variables:
    api_subdomain: "api-${CI_COMMIT_REF_SLUG}"
    antivirus_subdomain: "antivirus-${CI_COMMIT_REF_SLUG}"
    analytics_subdomain: "analytics-${CI_COMMIT_REF_SLUG}"
    s3_subdomain: "s3-${CI_COMMIT_REF_SLUG}"
    admin_subdomain: "admin-${CI_COMMIT_REF_SLUG}"
    gk_subdomain: "gk-${CI_COMMIT_REF_SLUG}"
    idp_subdomain: "idp-${CI_COMMIT_REF_SLUG}"
    vault_subdomain: "vault-${CI_COMMIT_REF_SLUG}"
    website_subdomain: "website-${CI_COMMIT_REF_SLUG}"
    maas_subdomain: "simulation-mass-${CI_COMMIT_REF_SLUG}"
    mailhog_subdomain: "mailhog-${CI_COMMIT_REF_SLUG}"
  before_script:
    - *cd-to-module
    - *declare-deployment-functions
    - *declare-image-functions
    - |
      echo "ENV_URL=https://${MODULE_NAME}-${CI_COMMIT_REF_SLUG}.${LANDSCAPE}.${BASE_DOMAIN}" > deployment.env
  script:
    - |
      deploy
  artifacts:
    paths:
      - ${MODULE_PATH:-${MODULE_NAME}}/k8s/${LANDSCAPE}
    reports:
      dotenv: ${MODULE_PATH:-${MODULE_NAME}}/deployment.env
  environment:
    name: ${CI_COMMIT_REF_SLUG}-${LANDSCAPE}/${MODULE_NAME}
    url: ${ENV_URL}

.preview-deploy-job:
  stage: deploy-preview
  extends:
    - .deploy-job
    - .preview-env-vars
    - .preview-deploy-tags
    - .auto-stop-preview
  variables:
    LANDSCAPE: preview
  environment:
    deployment_tier: development

.testing-deploy-job:
  stage: deploy-testing
  extends:
    - .deploy-job
    - .testing-env-vars
    - .testing-deploy-tags
    - .auto-stop-testing
    - .only-testing
    - .preprod-deploy-tags
    - .manual
  environment:
    deployment_tier: testing

.preprod-deploy-job:
  stage: deploy-preprod
  extends:
    - .deploy-job
    - .preprod-env-vars
    - .preprod-deploy-tags
    - .manual
  environment:
    deployment_tier: production

.undeploy-job:
  stage: cleanup
  extends:
    - .commons
    - .no-git-clone
    - .manual
    - .except-clean
  image: ${KUBETOOLS_IMAGE_TAGNAME}
  before_script:
    - *cd-to-module
    - *declare-deployment-functions
  script:
    - |
      undeploy
  environment:
    name: ${CI_COMMIT_REF_SLUG}-${LANDSCAPE}/${MODULE_NAME}
    action: stop

.preview-undeploy-job:
  extends:
    - .undeploy-job
    - .preview-env-vars
    - .preview-deploy-tags
  variables:
    LANDSCAPE: preview
  environment:
    deployment_tier: development

.testing-undeploy-job:
  extends:
    - .undeploy-job
    - .testing-env-vars
    - .testing-deploy-tags
    - .only-testing
  environment:
    deployment_tier: testing

.preprod-undeploy-job:
  extends:
    - .undeploy-job
    - .preprod-env-vars
    - .preprod-deploy-tags
  environment:
    deployment_tier: production

.handover-job:
  stage: handover
  extends:
    - .commons
    - .no-git-clone
    - .build-job-tags
    - .manual
    - .only-master
    - .except-clean
  image: ubuntu:20.04
  script:
    - |
      echo "pushing manifests to ops git repository"